//! A Verus grammar
//!
//! Explicitly ignores regions of the code that are outside the `verus!` macro.

// Legend:
//
//    //!                - documentation comment, for the full grammar
//    ///                - documentation comment
//    //                 - comment
//    foo = { ... }      - regular rule
//    baz = @{ ... }     - atomic
//    bar = _{ ... }     - silent
//    qux = ${ ... }     - compound-atomic
//    #tag = ...         - tags
//    plugh = !{ ... }   - non-atomic
//    "abc"              - exact string
//    ^"abc"             - case insensitive
//    'a'..'z'           - character range
//    ANY                - any character
//    foo ~ bar          - sequence
//    baz | qux          - ordered choice
//    foo*               - zero or more
//    bar+               - one or more
//    baz?               - optional
//    qux{n}             - exactly n
//    qux{m, n}          - between m and n (inclusive)
//    &foo               - positive predicate
//    !bar               - negative predicate

//***********************//
// General common things //
//***********************//

/// Allowed whitespace between any tokens in the grammar; completely ignored when the parsing is
/// done (except in cases such as strings or comments)
WHITESPACE = _{
  " " | "\t" | NEWLINE
}

/// Comment syntax; NOT ignored in the syntax tree that is parsed. Allowed to
/// exist between any tokens (except atomic tokens, of course).
COMMENT = @{
    // Outer docstring
    ("//!" ~ (!NEWLINE ~ ANY)* ~ NEWLINE)
    // Inner docstring
  | ("///" ~ (!NEWLINE ~ ANY)* ~ NEWLINE)
    // Multiline comment
  | multiline_comment
    // Singleline comment
  | ("//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE)
}

multiline_comment = @{
    "/*" ~ (multiline_comment | (!"*/" ~ ANY))* ~ "*/"
}

/// The entirety of a Verus source file
file = {
    SOI ~
    (non_verus ~ verus_macro_use)* ~
    non_verus? ~
    EOI
}

/// Region of code that doesn't contain any Verus macro use whatsoever
non_verus = @{
  (!("verus!" ~ WHITESPACE ~ "{") ~ ANY)*
}

/// An actual use of the `verus! { ... }` macro
verus_macro_use = ${
    "verus!" ~ WHITESPACE* ~ "{" ~ WHITESPACE* ~ verus_macro_body ~ WHITESPACE* ~ "}" ~ WHITESPACE* ~ ("//" ~ WHITESPACE* ~ "verus!")?
}

/// Anything inside the `verus! { ... }` macro
verus_macro_body = !{
    item*
}

/// A valid identifier, currently only supports ASCII-based identifiers, but
/// this probably should be extended in the future to correctly handle all
/// allowed identifiers.
identifier_string = @{
    (ASCII_ALPHA | "_") ~
    (ASCII_ALPHANUMERIC | "_")*
}

identifier = @{
    !(keyword ~ !(ASCII_ALPHA | "_" | ASCII_ALPHANUMERIC)) ~ identifier_string
}

hex_number = @{
    "0x" ~ (ASCII_HEX_DIGIT | "_")+
}

decimal_number = @{
    ASCII_DIGIT ~ ("_"? ~ ASCII_DIGIT)*
}

octal_number = @{
    "0o" ~ (ASCII_OCT_DIGIT | "_")+
}

binary_number = @{
    "0b" ~ ("0" | "1" | "_")+
}

int_number = @{
    (
        hex_number
      | decimal_number
      | octal_number
      | binary_number
    ) ~
    (
        "usize" | "u8" | "u16" | "u32" | "u64" | "u128"
      | "isize" | "i8" | "i16" | "i32" | "i64" | "i128"
      | "int"
      | "nat"
    )?
}

float_number = @{
    (ASCII_DIGIT | "_")+ ~
    "." ~
    (ASCII_DIGIT | "_")* ~
    ("f32" | "f64")?
}

lifetime_ident = @{
    "'" ~ ("_" | identifier | static_str)
}

/// A valid string, accounting for escaped quotes too.
string = @{
    "\"" ~ ("\\\"" | !"\"" ~ ANY)* ~ "\""
}

raw_string = @{
    "r" ~ PUSH("#"*) ~ "\""    // push the number signs onto the stack
    ~ raw_string_interior
    ~ "\"" ~ POP               // match a quotation mark and the number signs
}
raw_string_interior = {
    (
        !("\"" ~ PEEK)    // unless the next character is a quotation mark
                          // followed by the correct amount of number signs,
        ~ ANY             // consume one character
    )*
}

byte_string = @{
    "b" ~ string
}

raw_byte_string = @{
    "b" ~ raw_string
}

char = @{
    "'" ~ ("\\'" | !"'" ~ ANY)* ~ "'"
}

byte = @{
    "b" ~ char
}

//***********************************************************//
// Fixed strings we want to preserve in the formatted output //
//***********************************************************//
amp_str = { "&" }
at_str = { "@" }
bang_str = { "!" }
colon_str = { ":" }
colons_str = { "::" }
comma_str = { "," }
dash_str = { "-" }
dollar_str = { "$" }
dot_str = { "." }
dot_dot_str = { ".." }
dot_dot_eq_str = { "..=" }
ellipses_str = { "..." }
eq_str = { "=" }
fatarrow_str = { "=>" }
langle_str = { "<" }
lbrace_str = { "{" }
lbracket_str = { "[" }
lparen_str = { "(" }
pipe_str = { "|" }
pound_str = { "#" }
question_str = { "?" }
rangle_str = { ">" }
rarrow_str = { "->" }
rbrace_str = { "}" }
rbracket_str = { "]" }
rparen_str = { ")" }
semi_str = { ";" }
star_str = { "*" }
tilde_str = { "~" }
triple_and = { "&&&" }
triple_or = { "|||" }
underscore_str = { "_" }
as_str = { "as" }
assert_str = { "assert" }
assume_str = { "assume" }
async_str = { "async" }
auto_str = { "auto" }
await_str = { "await" }
box_str = { "box" }
break_str = { "break" }
by_str = { "by" }
by_str_inline = { "by" }
checked_str = { "checked" }
choose_str = { "choose" }
closed_str = { "closed" }
const_str = { "const" }
continue_str = { "continue" }
crate_str = { "crate" }
decreases_str = { "decreases" }
default_str = { "default" }
do_str = { "do" }
dyn_str = { "dyn" }
else_str = { "else" }
ensures_str = { "ensures" }
enum_str = { "enum" }
exec_str = { "exec" }
exists_str = { "exists" }
extern_str = { "extern" }
f32_str = { "f32" }
f64_str = { "f64" }
false_str = { "false" }
fn_str = { "fn" }
for_str = { "for" }
forall_str = { "forall" }
ghost_str = { "ghost" }
has_str = { "has" }
i128_str = { "i128" }
i16_str = { "i16" }
i32_str = { "i32" }
i64_str = { "i64" }
i8_str = { "i8" }
if_str = { "if" }
impl_str = { "impl" }
implies_str = { "implies" }
in_str = { "in" }
int_str = { "int" }
invariant_str = { "invariant" }
is_str = { "is" }
isize_str = { "isize" }
let_str = { "let" }
loop_str = { "loop" }
macro_str = { "macro" }
macro_rules_str = { "macro_rules" }
match_str = { "match" }
mod_str = { "mod" }
move_str = { "move" }
mut_str = { "mut" }
nat_str = { "nat" }
open_str = { "open" }
proof_str = { "proof" }
proof_space_str = { "proof" }
pub_str = { "pub" }
r_str = { "r" }
raw_str = { "raw" }
recommends_str = { "recommends" }
ref_str = { "ref" }
requires_str = { "requires" }
return_str = { "return" }
self_str = { "self" }
Self_str = { "Self" }
spec_str = { "spec" }
static_str = { "static" }
struct_str = { "struct" }
super_str = { "super" }
tracked_str = { "tracked" }
trait_str = { "trait" }
trigger_str = { "trigger" }
true_str = { "true" }
try_str = { "try" }
type_str = { "type" }
u128_str = { "u128" }
u16_str = { "u16" }
u32_str = { "u32" }
u64_str = { "u64" }
u8_str = { "u8" }
union_str = { "union" }
unsafe_str = { "unsafe" }
use_str = { "use" }
usize_str = { "usize" }
via_str = { "via" }
when_str = { "when" }
where_str = { "where" }
while_str = { "while" }
yeet_str = { "yeet" }
yield_str = { "yield" }

// See https://doc.rust-lang.org/reference/keywords.html
keyword = {
    // Strict
      as_str
    | break_str
    | const_str
    | continue_str
    | crate_str
    | else_str
    | enum_str
    | extern_str
    | false_str
    | fn_str
    | for_str
    | if_str
    | impl_str
    | in_str
    | let_str
    | loop_str
    | match_str
    | mod_str
    | move_str
    | mut_str
    | pub_str
    | ref_str
    | return_str
    | self_str
    | Self_str
    | static_str
    | struct_str
    | super_str
    | trait_str
    | true_str
    | type_str
    | unsafe_str
    | use_str
    | where_str
    | while_str
    | async_str
    | await_str
    | dyn_str
    
    // Reserved    
    | "abstract"
    | "become"
    | box_str
    | do_str
    | "final"
    | macro_str
    | "override_str"
    | "priv_str"
    | "typeof_str"
    | "unsized_str"
    | "virtual_str"
    | yield_str
    | try_str  
}

//*************************//
// Names, Paths and Macros //
//*************************//

name = { identifier | self_str }

// name_ref is used below in path_segments, which Rust says cannot
// contain numbers: https://doc.rust-lang.org/beta/reference/paths.html#paths-in-expressions
//name_ref = { identifier | int_number | self_str | super_str | crate_str | Self_str }
name_ref = { identifier | self_str | super_str | crate_str | Self_str }

lifetime = { lifetime_ident }

path = { (path_segment ~ colons_str)* ~ path_segment }

path_segment = {
    colons_str? ~ name_ref ~ generic_arg_list?
  | colons_str? ~ name_ref ~ param_list ~ ret_type?
  | colons_str? ~ name_ref
  | langle_str ~ path_type ~ (as_str ~ path_type)? ~ rangle_str
}

generic_args = {
    generic_arg ~ ("," ~ generic_arg)* ~ ","?
}

generic_arg_list = {
    colons_str? ~ langle_str ~ generic_args? ~ rangle_str
}

generic_arg = {
    type_arg
  | assoc_type_arg
  | lifetime_arg
  | const_arg
}

type_arg = {
    type
}

assoc_type_arg = {
    name_ref ~
    (generic_arg_list | param_list ~ ret_type?)? ~
    (colon_str ~ type_bound_list | (eq_str ~ type | const_arg))?
}

lifetime_arg = {
    lifetime
}

const_arg = {
    expr
}

// TODO: Special handling for the calc! and state_machine! macros?
macro_call = {
    attr* ~ path ~ bang_str ~ token_tree ~ semi_str?
}

// See https://doc.rust-lang.org/beta/reference/tokens.html#punctuation
punctuation = {
    bin_expr_ops
  | bang_str
  | triple_and 
  | triple_or
  | at_str
  | underscore_str
  | dot_str 
  | dot_dot_str
  | ellipses_str
  | dot_dot_eq_str
  | comma_str
  | semi_str
  | colon_str
  | colons_str
  | rarrow_str
  | fatarrow_str
  | pound_str
  | dollar_str
  | question_str
  | tilde_str
}

// See https://doc.rust-lang.org/beta/reference/tokens.html
token = {
    identifier
  | literal
  | lifetime_ident
  | keyword 
  | punctuation
}

delim_token_tree = {
      lparen_str ~ token_tree* ~ rparen_str
    | lbracket_str ~ token_tree* ~ rbracket_str
    | lbrace_str ~ token_tree* ~ rbrace_str
}

token_tree = {
    token | delim_token_tree
}

macro_items = {
    item*
}

macro_stmts = {
    stmt* ~ expr?
}

//*************************//
//          Items          //
//*************************//

item = {
    const
  | enum
  | extern_block
  | extern_crate
  | fn
  | impl
  | macro_call
  | macro_rules
  | macro_def
  | module
  | static
  | struct
  | trait
  | trait_alias
  | type_alias
  | union
  | use
}

macro_rules = {
    attr* ~ visibility? ~
    macro_rules_str ~ bang_str ~ name ~
    token_tree
}

macro_def = {
    attr* ~ visibility? ~
    macro_str ~ name ~ token_tree? ~
    token_tree
}

module = {
    attr* ~ visibility? ~
    mod_str ~ name ~
    (item_list | semi_str)
}

item_list = {
    "{" ~ attr* ~ item* ~ "}"
}

extern_crate = {
    attr* ~ visibility? ~
    extern_str ~ crate_str ~ name_ref ~ rename? ~ semi_str
}

rename = {
    as_str ~ (name | "_")
}

use = {
    attr* ~ visibility? ~
    use_str ~ use_tree ~ semi_str
}

use_tree = {
    (path? ~ colons_str)? ~ (star_str | use_tree_list)
  | path ~ rename?
}

use_tree_list = {
    "{" ~ (use_tree ~ ("," ~ use_tree)* ~ ","?)? ~ "}"
}

fn_qualifier = {
    prover? ~ where_clause? ~ requires_clause? ~ recommends_clause? ~ decreases_clause? ~ ensures_clause?
}

fn_terminator = {
    fn_block_expr 
  | semi_str
}

fn = {
    attr* ~ visibility? ~ publish? ~
    default_str? ~ const_str? ~ async_str? ~ unsafe_str? ~ abi? ~ fn_mode? ~
    fn_str ~ name ~ generic_param_list? ~ param_list ~ ret_type? ~
    fn_qualifier ~
    fn_terminator
}

abi = {
    extern_str ~ string?
}

param_list = {
    "(" ~ (
        (self_param ~ ",")? ~ param ~ ("," ~ param)*
      | self_param
    )? ~ ","? ~ ")"
}

closure_param_list = {
    "|" ~ (param ~ ("," ~ param)* ~ ","?)? ~ "|"
}

self_param = {
    attr* ~ (
        (amp_str ~ lifetime?)? ~ mut_str? ~ self_str
      | mut_str? ~ self_str ~ colon_str ~ type
    )
}

param = {
    attr* ~ (
        tracked_str? ~ pat_no_top_alt ~ (colon_str ~ type)?
        | type
        | ellipses_str
    )
}

ret_type = {
    rarrow_str ~ (tracked_str? ~ (lparen_str ~ name ~ colon_str ~ type ~ rparen_str | type))
}

type_alias = {
    attr* ~ visibility? ~
    default_str? ~
    type_str ~ name ~ generic_param_list? ~ (colon_str ~ type_bound_list)? ~ where_clause? ~
    (eq_str ~ type)? ~ semi_str
}

struct = {
    attr* ~ visibility? ~ data_mode? ~
    struct_str ~ name ~ generic_param_list? ~ (
        where_clause? ~ (record_field_list | semi_str)
      | tuple_field_list ~ where_clause? ~ semi_str
    )
}

// Each record must have its own line
record_field_list = {
    "{" ~ (record_field ~ ("," ~ record_field)* ~ ","?)? ~ "}"
}

// Records may be condensed onto a single line if sufficiently short
condensable_record_field_list = {
    "{" ~ (record_field ~ ("," ~ record_field)* ~ ","?)? ~ "}"
}

record_field = {
    attr* ~ visibility? ~ data_mode? ~
    name ~ colon_str ~ type
}

tuple_field_list = {
    "(" ~ (tuple_field ~ ("," ~ tuple_field)* ~ ","?)? ~ ")"
}

tuple_field = {
    attr* ~ visibility? ~
    data_mode? ~
    type
}

field_list = {
    condensable_record_field_list
  | tuple_field_list
}

enum = {
    attr* ~ visibility? ~
    enum_str ~ name ~ generic_param_list? ~ where_clause? ~
    variant_list
}

variant_list = {
    "{" ~ (variant ~ ("," ~ variant)* ~ ","?)? ~ "}"
}

variant = {
    attr* ~ visibility? ~
    name ~ field_list? ~ (eq_str ~ expr)?
}

union = {
    attr* ~ visibility? ~
    union_str ~ name ~ generic_param_list? ~ where_clause? ~
    record_field_list
}

const = {
    attr* ~ visibility? ~
    default_str? ~
    const_str ~ (name | "_") ~ colon_str ~ type ~
    eq_str ~ expr? ~ semi_str?  // Semi should not be included for const fn
}

static = {
    attr* ~ visibility? ~
    static_str ~ mut_str? ~ name ~ colon_str ~ type ~
    (eq_str ~ expr)? ~ semi_str
}

trait = {
    attr* ~ visibility? ~
    unsafe_str? ~ auto_str? ~
    trait_str ~ name ~ generic_param_list? ~
    (colon_str ~ type_bound_list)? ~ where_clause? ~ assoc_item_list
}

trait_alias = {
    attr* ~ visibility? ~
    trait_str ~ name ~ generic_param_list? ~ eq_str ~ type_bound_list? ~ where_clause? ~ semi_str
}

assoc_items = {
    assoc_item*
}

assoc_item_list = {
    "{" ~ attr* ~ assoc_items ~ "}"
}

assoc_item = {
    const
  | fn
  | macro_call
  | type_alias
}

impl = {
    attr* ~ visibility? ~
    default_str? ~ unsafe_str? ~
    impl_str ~ generic_param_list? ~ (const_str? ~ bang_str? ~ type ~ for_str)? ~ type ~ where_clause? ~
    assoc_item_list
}

extern_block = {
    attr* ~ unsafe_str? ~ abi ~ extern_item_list
}

extern_item_list = {
    "{" ~ attr* ~ extern_item* ~ "}"
}

extern_item = {
    fn
  | macro_call
  | static
  | type_alias
}

generic_param_list = {
    "<" ~ (generic_param ~ ("," ~ generic_param)* ~ ","?)? ~ ">"
}

generic_param = {
    const_param
  | lifetime_param
  | type_param
}

type_param = {
    attr* ~ name ~ (colon_str ~ type_bound_list)? ~
    (eq_str ~ type)?
}

const_param = {
    attr* ~ const_str ~ name ~ colon_str ~ type ~
    (eq_str ~ expr)?
}

lifetime_param = {
    attr* ~ lifetime ~ (colon_str ~ type_bound_list)?
}

where_clause = {
    where_str ~ (where_pred ~ ("," ~ where_pred)* ~ ","?)?
}

where_pred = {
    (for_str ~ generic_param_list)? ~ (lifetime | type) ~ colon_str ~ type_bound_list?
}

visibility = {
    pub_str ~ ("(" ~ (in_str)? ~ path ~ ")")?
}

attr_core = {
    trigger_attribute
    | "#" ~ bang_str? ~ "[" ~ meta ~ "]"
}
// Two aliases for attr_core, so that we can print them differently
attr = {
   attr_core
}

attr_inner = {
    attr_core
}

meta = {
    path ~ (eq_str ~ expr | token_tree)?
}

//****************************//
// Statements and Expressions //
//****************************//

stmt = {
    semi_str
  | proof_block
  | expr ~ semi_str
  | expr_with_block ~ semi_str?
  | item
  | let_stmt
}

let_stmt = {
    attr* ~ let_str ~ ghost_str? ~ tracked_str? ~ pat ~ (colon_str ~ type)? ~
    eq_str ~ expr ~
    let_else? ~
    semi_str
}

let_else = {
    else_str ~ block_expr
}

// This split of `expr` and `expr_inner` is to simply break the left-recursion
// that would happen otherwise.
expr = {
    expr_inner ~
    expr_outer*
}

expr_no_struct = {
    expr_inner_no_struct ~
    expr_outer_no_struct*
}

// In certain places, like the conditional for an if_expr,
// we have to prohibit struct_expr, since there is otherwise
// an ambiguity between struct_expr and pattern_expr.  E.g.,
//     let x = if b { 5 } else { 10 };
//     let u = MyStruct { x: 2, y: 3 };
expr_inner_no_struct = _{
    array_expr
  | assert_expr
  | assume_expr
  | assert_forall_expr
  | block_expr
  | box_expr
  | break_expr
  | prefix_expr
  | closure_expr
  | continue_expr
  | for_expr
  | if_expr
  | literal
  | loop_expr
  | macro_call
  | match_expr
  | paren_expr
  | ref_expr
  | return_expr
  | tuple_expr
  | while_expr
  | yield_expr
  | yeet_expr
  | let_expr
  | underscore_expr
  | path_expr   // Needs to be last, or it matches against keywords like "while"  
}

// The next three rules are defined to be atomic, since they
// all require one or more explicit whitespace tokens.
// This avoids, e.g., parsing "assert" has "as sert".
expr_as = ${
    as_str ~ WHITESPACE+ ~ type
}

expr_has = ${
    has_str ~ WHITESPACE+ ~ expr
}

expr_is = ${
    is_str ~ WHITESPACE+ ~ type
}

expr_outer = _{
    // await_expr
    dot_str ~ await_str
    // call_expr
    | arg_list
    // cast_expr
    | expr_as
    // collection test
    | expr_has
    // datatype test
    | expr_is
    // field_expr
    | dot_str ~ name_ref
    // tuple index
    | dot_str ~ int_number
    // try_expr
    | question_str
    // view_expr
    | at_str
    // index_expr
    | lbracket_str ~ expr ~ rbracket_str
    // method_call_expr
    | dot_str ~ name_ref ~ generic_arg_list? ~ arg_list
    // bin_expr
    | bin_expr_ops ~ expr
    // range_expr
    | (dot_dot_str | dot_dot_eq_str) ~ expr?
}

expr_outer_no_struct = _{
    // await_expr
    dot_str ~ await_str
    // call_expr
    | arg_list
    // cast_expr
    | expr_as
    // collection test
    | expr_has
    // datatype test
    | expr_is
    // field_expr
    | dot_str ~ name_ref
    // tuple index
    | dot_str ~ int_number
    // try_expr
    | question_str
    // view_expr
    | at_str
    // index_expr
    | lbracket_str ~ expr_no_struct ~ rbracket_str
    // method_call_expr
    | dot_str ~ name_ref ~ generic_arg_list? ~ arg_list
    // bin_expr
    | bin_expr_ops ~ expr_no_struct
    // range_expr
    | (dot_dot_str | dot_dot_eq_str) ~ expr_no_struct?
}

expr_inner = {
    if_expr  // Must precede struct_expr or struct_expr thinks `if {}` is a struct
  | struct_expr // Must precede expr_inner_no_struct or `my_struct { }` will be `my_struct`: path_expr
  | expr_inner_no_struct
}

expr_with_block = {
    block_expr
  | loop_expr
  | if_expr
  | match_expr
}

macro_expr = {
    macro_call
}

literal = {
    attr* ~ (
        int_number
      | float_number
      | string
      | raw_string
      | byte_string
      | raw_byte_string
      | true_str
      | false_str
      | char
      | byte
    )
}

path_expr = {
    attr* ~ path
}

stmt_list = {
    "{" ~
    attr* ~
    stmt* ~
    expr? ~
    "}"
}

ref_expr = {
    attr* ~ amp_str ~ (raw_str | mut_str | const_str)? ~ expr
}

proof_block = {
    attr* ~ label? ~ proof_space_str ~ stmt_list
}

block_expr = {
    proof_block
    | attr* ~ label? ~ (try_str | unsafe_str | async_str | const_str)? ~ stmt_list
}

fn_block_expr = {
    "{" ~
    attr* ~
    stmt* ~
    expr? ~
    "}"     
}

prefix_expr = {
    attr* ~ (dash_str | bang_str | star_str | triple_or | triple_and) ~ expr
}

assignment_ops = {
    "=" | "+=" | "/=" | "*=" | "%=" | ">>=" | "<<=" | "-=" | "|=" | "&=" | "^="
}

bin_expr_ops_special = {
    triple_or | triple_and
}

bin_expr_ops_normal = {
    | ("||" | "|")
    | ("&&" | "&")
    | "<==>"
    | "==="
    | "==>" | "<=="
    | "!=="
    | "==" | "!=" | "<=" | ">=" | "<" | ">"
    | "+" | "*" | "-" | "/" | "%" | "<<" | ">>" | "^"
    | assignment_ops
}

bin_expr_ops = {
    bin_expr_ops_special | bin_expr_ops_normal
}

paren_expr_inner = {
    "(" ~ expr ~ ")"
}

paren_expr = {
    attr* ~ paren_expr_inner
}

array_expr_inner = {
    "[" ~ attr* ~ (
        expr ~ semi_str ~ expr
      | comma_delimited_exprs?
    ) ~ "]"
}

array_expr = {
    attr* ~ array_expr_inner
}

tuple_expr_inner = {
    "(" ~ attr* ~ comma_delimited_exprs? ~ ")"
}

tuple_expr = {
    attr* ~ tuple_expr_inner
}

struct_expr = {
    path ~ record_expr_field_list
}

record_expr_field_list = {
    "{" ~
    attr* ~
    (record_expr_field ~ ("," ~ record_expr_field)* ~ ","?)? ~
    (dot_dot_str ~ expr)? ~
    "}"
}

record_expr_field = {
    attr* ~ (name ~ colon_str)? ~ expr
}

arg_list = {
    "(" ~ comma_delimited_exprs? ~ ")"
}

closure_expr = {
    attr* ~ (!forall_str ~ for_str ~ generic_param_list)? ~
    const_str? ~ static_str? ~ async_str? ~ move_str? ~ forall_str? ~ exists_str? ~ choose_str? ~
    closure_param_list ~ ret_type? ~
    attr_inner* ~
    expr
}

condition = { expr_no_struct }

if_expr = {
    attr* ~ if_str ~ condition ~ fn_block_expr ~
    (else_str ~ (if_expr | fn_block_expr))?
}

loop_expr = {
    attr* ~ label? ~ loop_str ~ fn_block_expr
}

for_expr = {
    attr* ~ label? ~ for_str ~ pat ~ in_str ~ expr_no_struct ~
    fn_block_expr
}

while_expr = {
    attr* ~ label? ~ while_str ~ condition ~ invariant_clause? ~ decreases_clause? ~
    fn_block_expr
}

label = {
    lifetime ~ colon_str
}

break_expr = {
    attr* ~ break_str ~ lifetime? ~ expr?
}

continue_expr = {
    attr* ~ continue_str ~ lifetime?
}

match_expr = {
    attr* ~ match_str ~ expr ~ match_arm_list
}

match_arm_list = {
    "{" ~
    attr* ~
    match_arm* ~
    "}"
}

match_arm_lhs = {
    attr* ~ pat ~ match_guard?
}

match_arm = {
    match_arm_lhs ~ "=>" ~ expr ~ ","?
}

match_guard = {
    if_str ~ expr
}

return_expr = {
    attr* ~ return_str ~ expr?
}

yield_expr = {
    attr* ~ yield_str ~ expr?
}

yeet_expr = {
    attr* ~ do_str ~ yeet_str ~ expr?
}

let_expr = {
    attr* ~ let_str ~ pat ~ eq_str ~ expr
}

underscore_expr = {
    attr* ~ "_"
}

box_expr = {
    attr* ~ box_str ~ expr
}

//*************************//
//          Types          //
//*************************//

type = {
    array_type
  | dyn_trait_type
  | fn_ptr_type
  | for_type
  | impl_trait_type
  | infer_type
  | macro_type
  | never_type
  | paren_type
  | path_type
  | ptr_type
  | ref_type
  | slice_type
  | tuple_type
}

paren_type = {
    "(" ~ type ~ ")"
}

never_type = {
    bang_str
}

macro_type = {
    macro_call
}

path_type = {
    path
}

tuple_type = {
    "(" ~ (type ~ ("," ~ type)* ~ ","?)? ~ ")"
}

ptr_type = {
    star_str ~ (const_str | mut_str) ~ type
}

ref_type = {
    "&" ~ lifetime? ~ mut_str? ~ type
}

array_type = {
    "[" ~ type ~ semi_str ~ expr ~ "]"
}

slice_type = {
    "[" ~ type ~ "]"
}

infer_type = {
    "_"
}

fn_ptr_type = {
    const_str? ~ async_str? ~ unsafe_str? ~ abi? ~ fn_str ~ param_list ~ ret_type?
}

for_type = {
    for_str ~ generic_param_list ~ type
}

impl_trait_type = {
    impl_str ~ type_bound_list
}

dyn_trait_type = {
    dyn_str ~ type_bound_list
}

type_bound_list = {
    type_bound ~ ("+" ~ type_bound)* ~ "+"?
}

type_bound = {
    lifetime
  | ("?" | "~" ~ const_str)? ~ type
}

//************************//
//        Patterns        //
//************************//


pat = {
    pat_inner ~ (
        // range_pat (for 1.. or 1..2)
        (dot_dot_eq_str | dot_dot_str) ~ pat?
        // or_pat
      | (pipe_str ~ pat_inner)* ~ pipe_str?
    )?
}

pat_no_top_alt = {
    pat_inner ~ (
        // range_pat (for 1.. or 1..2)
        (dot_dot_eq_str | dot_dot_str) ~ pat_no_top_alt?
    )?
}

pat_inner = {
    box_pat
  | rest_pat
  | literal_pat
  | macro_pat
  | paren_pat
//  | wildcard_pat
  | end_only_range_pat
  | record_pat
  | ref_pat
  | slice_pat
  | tuple_pat
  | tuple_struct_pat
  | const_block_pat
  | path_pat
  | ident_pat
}

literal_pat = {
    dash_str? ~ literal
}

ident_pat = {
    attr* ~ ref_str? ~ mut_str? ~ name ~ (at_str ~ pat)?
}

//wildcard_pat = {
//    "_"
//}

end_only_range_pat = {
    (dot_dot_eq_str | dot_dot_str) ~ pat
}

ref_pat = {
    "&" ~ mut_str? ~ pat
}

record_pat = {
    path ~ record_pat_field_list
}

record_pat_field_list = {
    "{" ~
    record_pat_field* ~ ("," ~ record_pat_field)* ~ ","? ~
    rest_pat? ~
    "}"
}

record_pat_field = {
    attr* ~ (name_ref ~ colon_str)? ~ pat
}

tuple_struct_pat_inner = {
    "(" ~ (pat ~ ("," ~ pat)* ~ ","?)? ~ ")"
}

tuple_struct_pat = {
    path ~ tuple_struct_pat_inner
}

tuple_pat = {
    "(" ~ (pat ~ ("," ~ pat)* ~ ","?)? ~ ")"
}

paren_pat = {
    "(" ~ pat ~ ")"
}

slice_pat = {
    "[" ~ (pat ~ ("," ~ pat)* ~ ","?)? ~ "]"
}

path_pat = {
    path
}

box_pat = {
    box_str ~ pat
}

rest_pat = {
    attr* ~ dot_dot_str
}

macro_pat = {
    macro_call
}

const_block_pat = {
    const_str ~ block_expr
}

//************************//
//        Verus           //
//************************//

publish = {
    closed_str
  | open_str
}

fn_mode = {
    mode_spec_checked
  | spec_str
  | proof_str
  | exec_str
}

mode_spec_checked = {
    spec_str ~ lparen_str ~ checked_str ~ rparen_str
}

data_mode = {
    ghost_str
  | tracked_str
}

comma_delimited_exprs = {
    expr ~ ("," ~ expr)* ~ ","?
}

// Prohibit top-level struct_expr, to avoid ambiguity for something like:
//    pub fn alice_addr(a:int) -> (b:int)
//        ensures a == b 
//    {
//        a
//    }
// where we could interpret the ensures expression as `a == b { a }`
comma_delimited_exprs_for_verus_clauses = {
    expr_no_struct ~ ("," ~ !verus_clause_non_expr ~ expr_no_struct)* ~ ","?
}

groupable_comma_delimited_exprs_for_verus_clauses = {
    comma_delimited_exprs_for_verus_clauses
}

verus_clause_non_expr = _{
    "{"             // TODO: Why is this permitted here?
  | requires_str
  | ensures_str
  | invariant_str
  | recommends_str
  | recommends_str
  | via_str
  | decreases_str
  | when_str
}

requires_clause = {
    requires_str ~ comma_delimited_exprs_for_verus_clauses
}

ensures_clause = {
    ensures_str ~ comma_delimited_exprs_for_verus_clauses
}

invariant_clause = {
    invariant_str ~ comma_delimited_exprs_for_verus_clauses
}

recommends_clause = {
    recommends_str ~ comma_delimited_exprs_for_verus_clauses ~ (via_str ~ expr_no_struct)?
}

decreases_clause = {
    decreases_str ~ groupable_comma_delimited_exprs_for_verus_clauses ~ (when_str ~ expr_no_struct)? ~ (via_str ~ expr_no_struct)?
}

assert_requires = {
    requires_clause
}

assert_expr = {
    attr* ~ assert_str ~ lparen_str ~ expr ~ rparen_str ~ (inline_prover ~ assert_requires? ~ block_expr?)?
}

assume_expr = {
    attr* ~ assume_str ~ lparen_str ~ expr ~ rparen_str
}

assert_forall_expr = {
    attr* ~ assert_str ~ lparen_str ~ forall_str ~ closure_expr ~ (implies_str ~ expr)? ~ rparen_str ~ by_str_inline ~ block_expr
}

inline_prover = {
    prover
}

prover = {
    by_str ~ (lparen_str ~ name ~ rparen_str)?
}

trigger_attribute = {
    "#" ~ "!" ~ "[" ~ trigger_str ~ comma_delimited_exprs? ~ "]"
}